---
title: "BinTP/1：一个简单的 HTTP/1.1 仿制品，长度更短但没什么用"
---

十月份一直在看网络上的东西，所以也开始想做些相关（而且能做出来的）小项目试试。\
因为这里的“网络”指的是现代意义上的前端和 HTTP 服务器所以这次的目标也就定为成与 HTTP 相关的东西咯

## 新协议？

BinTP -> Binary Transfer Protocol -> 二进制传输协议

HTTP/1.1 协议中使用直接的字符传递标头，之前我也一直有对它性能和带宽占用的疑惑。\
所以，如果把它们换成二进制的呢。当然，如果能再让加上些更有趣的功能不是更有趣了吗。这就是项目的初衷

BinTP 的第一个版本大概会去实现类似 HTTP/1.1 的功能，概念中甚至能与它互相转译

## 从理智的角度看，它与 HTTP 会有优势吗

没有，或者说对比与 HTTP/2 甚至 HTTP/3 而言不可能有任何优势。但这很酷，至少能去欺负欺负 HTTP/1.1 对吧（笑）。\
HTTP/2 使用 HPACK 压缩标头，这本身就几乎让整个项目显得毫无意义：[HPACK: the silent killer (feature) of HTTP/2](https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/)

## 请求格式

不同于 HTTP，所有 BinTP 请求都已一个 `uint8` 开始来表明版本，比如开发中的不稳定版本使用的就是 0（想写 `0x0`）。\
版本号大概率是不会超过 256 的，但至于像 HTTP/0.9, 1.0, 1.1 这样的子版本号就用不了了，不过现在来看倒也用不太到这些就是了

随后是与 HTTP 一样的请求方法与 URI 字符串：`| uint8 方法 | URI | char[2] CRLF |`\
其中，请求方法是长8bit的二进制格式，URI 则与 HTTP 所使用的 [RFC 3986](https://www.rfc-editor.org/info/rfc3986) 标准一致，但以 `\r\n` 也就是 CRLF 结尾。\
说不定这个方案以后会改吧...

接下来就是标头：

```text
| uint8 长度 | binary 名称 | uint8 长度 | binary 值 |
```

> 长度的单位都是 byte

不过 值 的表示方式不一定为二进制而是取决于该字段的定义，就像 HTTP 标头里的逗号那样，但这部分还没想好就是了

标头以一个名称长度为0的空字段结尾，且不包含值的长度信息（省一个没必要的 byte），实际负载将紧跟着发送出去

```text
| ... | 0x00 | load |
```

## 响应格式

首先是 uint8 的版本号。\
紧接着的就是响应状态码，但考虑到能直接用 HTTP 的状态码嘛，还是选 uint16 吧（懒蛋是这样的，下个版本肯定会改啦）。\
随后则是与请求格式一样的标头字段：

```text
| uint8 version | uint16 status | headers ... | 0x00 | load |
```

## 标头字段的格式和对照

我不认为直接将所有官方标头一一对照是个好想法，但我们应该也需要些官方标头。\
或者，等之后再慢慢看看吧...

## 还需要想的事情

嘛，这点东西太简单了（捂脸）。不过没事，拿来练练手还是很合适的

在想标准的时候 HTTP/1.1 的 Connection 标头让我一直摇摆不定，既然这是个很底层的协议，那要不要做些更好的连接控制方式呢。\
但以目前的协议框架来说要扩展这一部分就意味着要改动标头字段前的内容顺序，而且... 我不知道我要做什么

或许等未来一段时间去深入的看看 HTTP/2 再来想这一部分吧

## 实现

我的请求与响应的生成与解析库（C 语言）：[SourLemonJuice/BinTP](https://github.com/SourLemonJuice/BinTP)
